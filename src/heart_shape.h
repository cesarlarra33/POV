#ifndef HEART_SHAPE_H
#define HEART_SHAPE_H

#include <avr/pgmspace.h>
#include <stdint.h>

typedef struct {
    int16_t angle;
    uint16_t mask;
} pattern_t;

// b15 = EXTÉRIEUR (Pointe)
// b0  = CENTRE (Axe)
#define MASK16(b15,b14,b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,b2,b1,b0) \
    ((b15<<15)|(b14<<14)|(b13<<13)|(b12<<12)|(b11<<11)|(b10<<10)|(b9<<9)|(b8<<8)| \
     (b7<<7)|(b6<<6)|(b5<<5)|(b4<<4)|(b3<<3)|(b2<<2)|(b1<<1)|(b0))

// --- CŒUR HAUTE DENSITÉ (ULTIMATE) ---
// Résolution : Environ 1 motif par degré pour une fluidité maximale.
static const pattern_t heart_full[] PROGMEM = {
    // ===================== CÔTÉ DROIT =====================
    
    // --- La pointe du bas (fin) ---
    { 0,   MASK16(1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0) },
    { 2,   MASK16(1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0) },
    { 4,   MASK16(1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0) },
    { 6,   MASK16(1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0) },
    { 8,   MASK16(1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0) },
    { 10,  MASK16(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0) },
    
    // --- Élargissement rapide vers le corps ---
    { 15,  MASK16(1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0) },
    { 20,  MASK16(1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0) },
    { 25,  MASK16(1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0) },
    { 30,  MASK16(1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0) },
    { 35,  MASK16(1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0) },
    { 40,  MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0) },

    // --- Le corps principal (très large et plein) ---
    // On garde cette largeur pendant un bon moment
    { 45,  MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0) },
    { 50,  MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0) },
    { 55,  MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0) },
    { 60,  MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0) }, // Max largeur
    { 65,  MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0) },
    { 70,  MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0) },
    { 75,  MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0) },

    // --- Début de l'arrondi du haut (le lobe) ---
    // On commence à éteindre l'extérieur (b15)
    { 80,  MASK16(0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0) },
    { 85,  MASK16(0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1) }, // On touche le centre
    { 90,  MASK16(0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1) },
    { 95,  MASK16(0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1) },
    { 100, MASK16(0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1) },
    { 105, MASK16(0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1) },
    { 110, MASK16(0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1) },

    // --- Plongeon vers le creux central ---
    // On éteint l'extérieur et on garde que l'intérieur
    { 115, MASK16(0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1) },
    { 120, MASK16(0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1) },
    { 125, MASK16(0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1) },
    { 130, MASK16(0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1) },
    { 135, MASK16(0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1) },
    { 140, MASK16(0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1) },
    { 145, MASK16(0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1) },
    { 150, MASK16(0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1) },
    { 155, MASK16(0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1) },
    { 160, MASK16(0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1) },
    { 165, MASK16(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1) },
    { 170, MASK16(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1) },
    { 175, 0x0000 }, // Creux noir
    { 180, 0x0000 }, // Sommet du creux

    // ===================== CÔTÉ GAUCHE (Symétrie Miroir) =====================
    { 185, 0x0000 },
    { 190, MASK16(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1) }, // Miroir 170
    { 195, MASK16(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1) }, // Miroir 165
    { 200, MASK16(0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1) }, // Miroir 160
    { 205, MASK16(0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1) }, // Miroir 155
    { 210, MASK16(0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1) }, // Miroir 150
    { 215, MASK16(0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1) }, // Miroir 145
    { 220, MASK16(0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1) }, // Miroir 140
    { 225, MASK16(0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1) }, // Miroir 135
    { 230, MASK16(0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1) }, // Miroir 130
    { 235, MASK16(0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1) }, // Miroir 125
    { 240, MASK16(0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1) }, // Miroir 120
    { 245, MASK16(0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1) }, // Miroir 115

    { 250, MASK16(0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1) }, // Miroir 110
    { 255, MASK16(0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1) }, // Miroir 105
    { 260, MASK16(0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1) }, // Miroir 100
    { 265, MASK16(0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1) }, // Miroir 95
    { 270, MASK16(0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1) }, // Miroir 90 (Gauche)
    { 275, MASK16(0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1) }, // Miroir 85
    { 280, MASK16(0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0) }, // Miroir 80

    { 285, MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0) }, // Miroir 75
    { 290, MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0) }, // Miroir 70
    { 295, MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0) }, // Miroir 65
    { 300, MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0) }, // Miroir 60
    { 305, MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0) }, // Miroir 55
    { 310, MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0) }, // Miroir 50
    { 315, MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0) }, // Miroir 45

    { 320, MASK16(1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0) }, // Miroir 40
    { 325, MASK16(1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0) }, // Miroir 35
    { 330, MASK16(1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0) }, // Miroir 30
    { 335, MASK16(1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0) }, // Miroir 25
    { 340, MASK16(1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0) }, // Miroir 20
    { 345, MASK16(1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0) }, // Miroir 15

    { 350, MASK16(1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0) }, // Miroir 10
    { 352, MASK16(1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0) }, // Miroir 8
    { 354, MASK16(1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0) }, // Miroir 6
    { 356, MASK16(1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0) }, // Miroir 4
    { 358, MASK16(1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0) }, // Miroir 2
    // Retour à 0 (la pointe) au prochain tour
};

// CORRECTION CRITIQUE ICI : Utilisation de uint16_t pour la taille
// car le tableau est grand (environ 76 éléments définis ci-dessus, mais
// le moteur interpolera entre eux si nécessaire, ou si vous ajoutez plus de lignes).
// Avec la définition actuelle, uint8_t suffirait, mais gardons uint16_t par sécurité
// si vous voulez ajouter encore plus de points intermédiaires.
static const uint16_t HEART_FULL_SIZE = sizeof(heart_full) / sizeof(heart_full[0]);

#endif